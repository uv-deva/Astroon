//   /$$$$$$  /$$$$$$ /$$$$$$$$/$$$$$$$  /$$$$$$  /$$$$$$ /$$   /$$
//  /$$__  $$/$$__  $|__  $$__| $$__  $$/$$__  $$/$$__  $| $$$ | $$
// | $$  \ $| $$  \__/  | $$  | $$  \ $| $$  \ $| $$  \ $| $$$$| $$
// | $$$$$$$|  $$$$$$   | $$  | $$$$$$$| $$  | $| $$  | $| $$ $$ $$
// | $$__  $$\____  $$  | $$  | $$__  $| $$  | $| $$  | $| $$  $$$$
// | $$  | $$/$$  \ $$  | $$  | $$  \ $| $$  | $| $$  | $| $$\  $$$
// | $$  | $|  $$$$$$/  | $$  | $$  | $|  $$$$$$|  $$$$$$| $$ \  $$
// |__/  |__/\______/   |__/  |__/  |__/\______/ \______/|__/  \__/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

/**
 * @title ASTILO
 * @dev ASTILO contract is Ownable
 **/
contract ASTILO is
    OwnableUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable
{
    IERC20Upgradeable token;
    /// @dev Merkle root for a whitelist users
    bytes32 private merkleRoot;

    uint256 private saleId;
    uint256 public initialTokens; // Initial number of tokens available
    uint256 public raisedAmount;
    bool public presaleM;
    bool public publicM;

    struct SaleDetail {
        uint256 rate; // Number of tokens per Ether
        uint256 cap; // Cap in Ether
        uint256 start; // Oct 17, 2022 @ 12:00 EST
        uint256 _days; // 45 Day
        uint256 cliff;
        uint256 vesting;
        uint256 thresHold;

    }

    struct UserToken {
        uint256 saleRound;
        uint256 tokens;
        uint256 claimed;
        uint256 lastClaimed;
        uint256 createdOn;
    }


    mapping(uint256 => SaleDetail) public salesDetailMap;
    mapping(uint256=>mapping(address => UserToken)) public userTokenMap;


    /**
     * BoughtTokens
     * @dev Log tokens bought onto the blockchain
     */
    event BoughtTokens(address indexed to, uint256 value, uint256 saleId);
    event SaleCreated(uint256 saleId);
    event Claimed(address indexed receiver, uint256 amount, uint256 saleId);

    /**
     * initialize
     * @dev Initialize the contract
     **/
    function initialize(address _tokenAddr, uint256 _initialTokens)
        external
        initializer
    {
        require(_tokenAddr != address(0));
        require(_initialTokens > 0);
        initialTokens = _initialTokens * 10**18;

        __Ownable_init();
        __Pausable_init();
        __ReentrancyGuard_init();
        token = IERC20Upgradeable(_tokenAddr);
    }

    /**
     * @notice startTokenSale for starting any token sale
     */
    function startTokenSale(
        uint256 _rate,
        uint256 _cap,
        uint256 _start,
        uint256 _ddays,
        uint256 _thresHold,
        uint256 _cliff,
        uint256 _vesting
    ) external whenNotPaused onlyOwner returns (uint256) {
        saleId++;
        SaleDetail memory detail;
        detail.rate = _rate;
        detail.cap = _cap;
        detail.start = _start;
        detail._days = _ddays;
        detail.cliff = block.timestamp + (_cliff * 1 days);
        detail.vesting = _vesting;
        detail.thresHold = _thresHold;
        salesDetailMap[saleId] = detail;

        emit SaleCreated(saleId);
        return saleId;
    }
    


    /**
     * @notice Update Merkel Root to Whitelist users
     * @param _merkleRoot for whitelist users
     */
    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {
        merkleRoot = _merkleRoot;
    }

    function togglePresale() public onlyOwner {
        presaleM = !presaleM;
    }
    
     
    function togglePublicSale() public onlyOwner {
        publicM = !publicM;
    }

    function pause() public onlyOwner {
        _pause();
    }
    // abcdefghijklmnopqrstuvwxyz

    function unpause() public onlyOwner {
        _unpause();
    }

    /**
     * @notice get curren active merkel root
     */
    function getMerkleRoot() external view returns (bytes32) {
        return merkleRoot;
    }

    /**
     * @notice check user whitelist or not
     * @param _merkleProof merkelProof generated by MerkelTree for current MerkelRoot
     */
    modifier checkWhitelist(bytes32[] memory _merkleProof) {
        bytes32 sender = keccak256(abi.encodePacked(_msgSender()));
        require(
            MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, sender),
            "not whitelisted"
        );
        _;
    }

    /**
     * isActive
     * @dev Determins if the contract is still active
     **/
    function isActive(uint256 _saleId) public view returns (bool) {
        SaleDetail memory detail = salesDetailMap[_saleId];
        return (block.timestamp >= detail.start && // Must be after the start date
            block.timestamp <= detail.start + (detail._days * 1 days) && // Must be before the end date
            goalReached(_saleId) == false); // Goal must not already be reached
    }

    /**
     * goalReached
     * @dev Function to determin is goal has been reached
     **/
    function goalReached(uint256 _saleId) public view returns (bool) {
        SaleDetail memory detail = salesDetailMap[_saleId];
        return (raisedAmount >= detail.cap * 1 ether);
    }

    /**
     * @dev Fallback function if ether is sent to address insted of buyTokens function
     **/
    fallback() external payable {
        buyTokens();
    }

    receive() external payable {
        buyTokens();
    }

    /**
     * buyTokens
     * @dev function that sells available tokens
     **/
    function preSaleBuy(bytes32[] calldata _proof)
        public
        payable
        whenNotPaused
        nonReentrant
        checkWhitelist(_proof)
    {
        require(presaleM, "Presale is OFF");
        require(msg.value > 0, "invalid amount");
        SaleDetail memory detail = salesDetailMap[saleId];
        uint256 _tokens = calculateToken(msg.value, detail.rate);
        require(_tokens <= detail.thresHold, "buying more than max allowed");
        UserToken memory userToken;
        userToken.saleRound = saleId;
        userToken.createdOn = block.timestamp;
        userToken.lastClaimed = block.timestamp;
        userToken.tokens += _tokens;
        
        emit BoughtTokens(msg.sender, _tokens, saleId); // log event onto the blockchain
        raisedAmount += msg.value; // Increment raised amount
        userTokenMap[saleId][_msgSender()] = userToken;
        payable(owner()).transfer(msg.value); // Send money to owner
    }

    function calculateToken(uint256 amount, uint256 _rate)
        public
        pure
        returns (uint256)
    {
        return (amount / _rate) * 10**18;
    }

    function claim(uint256 _saleId) external whenNotPaused nonReentrant {
        SaleDetail memory detail = salesDetailMap[_saleId];
        require(block.timestamp > detail.cliff, "cliff not ended");
        UserToken memory utoken = userTokenMap[_saleId][_msgSender()];
        require(utoken.saleRound == _saleId, "not purchase data");
        uint256 amount = _calculateReleaseToken(
            utoken.tokens,
            detail.vesting,
            utoken.lastClaimed
        );
        require(amount < tokensAvailable(), "insufficent token balance");
        utoken.claimed += amount;
        utoken.lastClaimed = block.timestamp;
        userTokenMap[_saleId][_msgSender()] = utoken;
        token.transfer(_msgSender(), amount);
        emit Claimed(_msgSender(), amount, _saleId);
    }

    function _calculateReleaseToken(
        uint256 _token,
        uint256 vesting,
        uint256 lastClaimed
    ) internal view returns (uint256) {
        uint256 tokenperDay = _token / vesting;
        return tokenperDay * _getDays(lastClaimed);
    }

    function _getDays(uint256 _timestamp) internal view returns (uint256) {
        return (block.timestamp - _timestamp) / 86400;
    }

    /**
     *
     * buyTokens
     * @dev function that sells available tokens
     **/
    function buyTokens() public payable whenNotPaused nonReentrant {
        require(publicM, "sale is OFF");
        SaleDetail memory detail = salesDetailMap[saleId];
        uint256 tokens = calculateToken(msg.value, detail.rate);
        require(tokens < tokensAvailable(), "insufficent token balance");
        emit BoughtTokens(msg.sender, tokens, saleId); // log event onto the blockchain
        raisedAmount += msg.value; // Increment raised amount
        token.transfer(msg.sender, tokens); // Send tokens to buyer
        payable(owner()).transfer(msg.value); // Send money to owner

    }

    /**
     * tokensAvailable
     * @dev returns the number of tokens allocated to this contract
     **/
    function tokensAvailable() public view returns (uint256) {
        return token.balanceOf(address(this));
    }

    function withdrawETH(address admin) external onlyOwner {
        payable(admin).transfer(address(this).balance);
    }

    function withdrawToken(address admin, address _paymentToken)
        external
        onlyOwner
    {
        IERC20Upgradeable _token = IERC20Upgradeable(_paymentToken);
        uint256 amount = _token.balanceOf(address(this));
        token.transfer(admin, amount);
    }
}