//   /$$$$$$  /$$$$$$ /$$$$$$$$/$$$$$$$  /$$$$$$  /$$$$$$ /$$   /$$
//  /$$__  $$/$$__  $|__  $$__| $$__  $$/$$__  $$/$$__  $| $$$ | $$
// | $$  \ $| $$  \__/  | $$  | $$  \ $| $$  \ $| $$  \ $| $$$$| $$
// | $$$$$$$|  $$$$$$   | $$  | $$$$$$$| $$  | $| $$  | $| $$ $$ $$
// | $$__  $$\____  $$  | $$  | $$__  $| $$  | $| $$  | $| $$  $$$$
// | $$  | $$/$$  \ $$  | $$  | $$  \ $| $$  | $| $$  | $| $$\  $$$
// | $$  | $|  $$$$$$/  | $$  | $$  | $|  $$$$$$|  $$$$$$| $$ \  $$
// |__/  |__/\______/   |__/  |__/  |__/\______/ \______/|__/  \__/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

/**
 * @title ASTILO
 * @dev ASTILO contract is Ownable
 **/
contract ASTILO is OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
    IERC20Upgradeable token;
    /// @dev Merkle root for a whitelist users
    bytes32 private merkleRoot;

    uint256 private saleId;
    uint256 public initialTokens; // Initial number of tokens available
    bool public presaleM;
    bool public publicM;

    struct SaleDetail {
        uint256 rate; // Number of tokens per Ether
        uint256 cap; // Cap in Ether
        uint256 start; // Oct 17, 2022 @ 12:00 EST
        uint256 _days; // 45 Day
        uint256 cliffDuration;
        uint256 vesting;
        uint256 thresHold;
        uint256 raisedIn;
        uint256 tokenSold;
        uint256 minBound; //min to buy
    }

    struct UserToken {
        uint256 saleRound;
        uint256 tokens;
        uint256 claimed;
        uint256 lastClaimed;
        uint256 createdOn;
        uint256 cliff;
    }

    mapping(uint256 => SaleDetail) public salesDetailMap;
    mapping(uint256 => mapping(address => UserToken)) public userTokenMap;

    /**
     * BoughtTokens
     * @dev Log tokens bought onto the blockchain
     */
    event BoughtTokens(address indexed to, uint256 value, uint256 saleId);
    event SaleCreated(uint256 saleId);
    event Claimed(address indexed receiver, uint256 amount, uint256 saleId);

    /**
     * initialize
     * @dev Initialize the contract
     **/
    function initialize(address _tokenAddr, uint256 _initialTokens) external initializer {
        require(_tokenAddr != address(0));
        require(_initialTokens > 0);
        initialTokens = _initialTokens * 10**18;

        __Ownable_init();
        __Pausable_init();
        __ReentrancyGuard_init();
        token = IERC20Upgradeable(_tokenAddr);
    }

    /**
     * @notice startTokenSale for starting any token sale
     */

    function set_initialTokens(uint256 _newValue) external onlyOwner {
        initialTokens = _newValue * 10**18;
    }

    function startTokenSale(
        uint256 _rate,
        uint256 _cap,
        uint256 _start,
        uint256 _ddays,
        uint256 _thresHold,
        uint256 _cliffDuration,
        uint256 _vesting,
        uint256 _minBound
    ) external whenNotPaused onlyOwner returns (uint256) {
        saleId++;

        salesDetailMap[saleId] = SaleDetail(
            _rate,
            _cap,
            _start,
            _ddays,
            _cliffDuration * 1 days,
            _vesting,
            _thresHold,
            salesDetailMap[saleId].raisedIn,
            salesDetailMap[saleId].tokenSold,
            _minBound
        );
        emit SaleCreated(saleId);
        return saleId;
    }

    /**
     * @notice Update Merkel Root to Whitelist users
     * @param _merkleRoot for whitelist users
     */
    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {
        merkleRoot = _merkleRoot;
    }

    function togglePresale() external onlyOwner {
        presaleM = !presaleM;
    }

    function togglePublicSale() external onlyOwner {
        publicM = !publicM;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice get curren active merkel root
     */
    function getMerkleRoot() external view returns (bytes32) {
        return merkleRoot;
    }

    /**
     * @notice check user whitelist or not
     * @param _merkleProof merkelProof generated by MerkelTree for current MerkelRoot
     */
    modifier checkWhitelist(bytes32[] memory _merkleProof) {
        bytes32 sender = keccak256(abi.encodePacked(_msgSender()));
        require(MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, sender), "not whitelisted");
        _;
    }

    /**
     * isActive
     * @dev Determins if the contract is still active
     **/
    function isActive(uint256 _saleId) public view returns (bool) {
        SaleDetail memory detail = salesDetailMap[_saleId];
        return (block.timestamp >= detail.start && // Must be after the start date
            block.timestamp <= detail.start + (detail._days * 1 days) && // Must be before the end date
            goalReached(_saleId) == false); // Goal must not already be reached
    }

    /**
     * goalReached
     * @dev Function to determin is goal has been reached
     **/
    function goalReached(uint256 _saleId) public view returns (bool) {
        SaleDetail memory detail = salesDetailMap[_saleId];
        return (detail.raisedIn >= detail.cap * 1 ether);
    }

    /**
     * @dev Fallback function if ether is sent to address insted of buyTokens function
     **/
    fallback() external payable {
        buyTokens();
    }

    receive() external payable {
        buyTokens();
    }

    /**
     * buyTokens
     * @dev function that sells available tokens
     **/
    function preSaleBuy(bytes32[] calldata _proof) external payable whenNotPaused nonReentrant checkWhitelist(_proof) {
        require(isActive(saleId), "Sale is not active");
        require(presaleM, "Presale is OFF");
        SaleDetail memory detail = salesDetailMap[saleId];
        require(msg.value > 0, "invalid amount");
        UserToken memory userToken;
        uint256 _tokens = calculateToken(msg.value, detail.rate);
        require(
            _tokens >= detail.minBound && _tokens <= detail.thresHold && _tokens <= initialTokens,
            "buying more than max allowed"
        );
        userToken.saleRound = saleId;
        userToken.createdOn = block.timestamp;
        userToken.lastClaimed = block.timestamp;
        userToken.tokens += _tokens;
        userToken.cliff = block.timestamp + detail.cliffDuration;

        emit BoughtTokens(msg.sender, _tokens, saleId); // log event onto the blockchain
        detail.tokenSold += _tokens;
        initialTokens -= _tokens;
        detail.raisedIn += msg.value; // Increment raised amount
        userTokenMap[saleId][_msgSender()] = userToken;
        payable(owner()).transfer(msg.value); // Send money to owner
    }

    function calculateToken(uint256 amount, uint256 _rate) public pure returns (uint256) {
        return (amount / _rate) * 10**18;
    }

    function claim(uint256 _saleId) external whenNotPaused nonReentrant {
        SaleDetail memory detail = salesDetailMap[_saleId];
        UserToken memory utoken = userTokenMap[_saleId][_msgSender()];
        require(block.timestamp > utoken.cliff, "cliff not ended");
        require(utoken.saleRound == _saleId, "not purchase data");
        uint256 claimedOn = utoken.lastClaimed == utoken.createdOn ? utoken.cliff : utoken.lastClaimed;
        uint256 amount = calculateReleaseToken(utoken.tokens, detail.vesting, claimedOn);
        require(amount > 0, "no rewards");
        require(amount < tokensAvailable(), "insufficent token balance");
        utoken.claimed += amount;
        utoken.lastClaimed = block.timestamp;
        userTokenMap[_saleId][_msgSender()] = utoken;
        token.transfer(_msgSender(), amount);
        emit Claimed(_msgSender(), amount, _saleId);
    }

    function calculateReleaseToken(
        uint256 _token,
        uint256 vesting,
        uint256 lastClaimed
    ) public view returns (uint256) {
        uint256 tokenperDay = _token / vesting;
        return tokenperDay * _getDays(lastClaimed);
    }

    function getReward(uint256 _saleId, address _addr) external view whenNotPaused returns (uint256) {
        SaleDetail memory detail = salesDetailMap[_saleId];
        UserToken memory utoken = userTokenMap[_saleId][_addr];
        uint256 claimedOn = utoken.lastClaimed == utoken.createdOn ? utoken.cliff : utoken.lastClaimed;
        uint256 amount = calculateReleaseToken(utoken.tokens, detail.vesting, claimedOn);
        return amount;
    }

    function _getDays(uint256 _timestamp) internal view returns (uint256) {
        return (block.timestamp - _timestamp) / 86400;
    }

    function updateClaim(
        uint256 _saleId,
        uint256 _date,
        address _user
    ) external onlyOwner {
        UserToken memory utoken = userTokenMap[_saleId][_user];
        require(utoken.saleRound == _saleId, "not purchase data");
        utoken.lastClaimed = _date;
        userTokenMap[_saleId][_user] = utoken;
    }

    /**
     *
     * buyTokens
     * @dev function that sells available tokens
     **/
    function buyTokens() public payable whenNotPaused nonReentrant {
        require(isActive(saleId), "Sale is not active");
        require(publicM, "sale is OFF");
        require(msg.value > 0);
        SaleDetail memory detail = salesDetailMap[saleId];
        uint256 tokens = calculateToken(msg.value, detail.rate);
        require(tokens < detail.thresHold, "buying more than max allowed");
        emit BoughtTokens(msg.sender, tokens, saleId); // log event onto the blockchain
        detail.raisedIn += msg.value; // Increment raised amount
        detail.tokenSold += tokens;
        initialTokens -= tokens;

        token.transfer(msg.sender, tokens); // Send tokens to buyer

        payable(owner()).transfer(msg.value); // Send money to owner
    }

    /**
     * tokensAvailable
     * @dev returns the number of tokens allocated to this contract
     **/
    function tokensAvailable() public view returns (uint256) {
        return token.balanceOf(address(this));
    }

    function withdrawETH(address admin) external onlyOwner {
        payable(admin).transfer(address(this).balance);
    }

    function withdrawToken(address admin, address _paymentToken) external onlyOwner {
        IERC20Upgradeable _token = IERC20Upgradeable(_paymentToken);
        uint256 amount = _token.balanceOf(address(this));
        token.transfer(admin, amount);
    }
}
